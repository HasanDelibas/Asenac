
"use strict";
//@ts-ignore
Array.prototype.popAt = function (index) {
    if (index == null) {
        index = this.length - 1;
    }
    return this.splice(index, 1)[0];
};
Array.prototype.unique = function () {
    function onlyUnique(value, index, self) {
        return self.indexOf(value) === index;
    }
    return this.filter(onlyUnique);
};
Array.prototype.distinct = function (fn = (a, b) => { return a == b; }) {
    let i = 0;
    for (i = 0; i < this.length; i++) {
        const element = this[i];
        let find = this.filter(e => { return fn(element, e); });
        for (let j = 1; j < find.length; j++) {
            const element = find[j];
            this.popAt(this.indexOf(element));
        }
    }
};
String.prototype.replaceAll = function (search, replacement) {
    var target = this;
    return target.split(search).join(replacement);
};
// "" tırnak işaretlerini siler
String.prototype.trimQuotes = function () {
    var str = this;
    str = str.trim();
    if (str[0] == "\"" || str[0] == "'")
        str = str.substr(1);
    if (str[str.length - 1] == "\"" || str[str.length - 1] == "'")
        str = str.substr(0, str.length - 1);
    return str;
};
String.prototype.matchRequirsive = function (start, end, position = 0) {
    var search = this;
    var total = 0, startLen = start.length, endLen = end.length;
    var startPoint = -1;
    for (let i = position; i < search.length - endLen + 1; i++) {
        const element = search[i];
        //console.log(i,element,total,startPoint);
        if (search.substr(i, startLen) == start) {
            //console.log("S:",i)
            total++;
            if (startPoint == -1)
                startPoint = i;
            i += startLen - 1;
        }
        if (search.substr(i, endLen) == end) {
            //console.log("E:",i)
            total--;
            if (total == 0 && startPoint != -1) {
                return [
                    search.substr(startPoint, i + endLen - startPoint),
                    search.substr(startPoint + startLen, i - startPoint - startLen),
                    startPoint + startLen,
                    i + endLen
                ];
            }
            i += endLen - 1;
        }
    }
    return null;
};
String.prototype.pop = function (start, length) {
    return this.substr(0, start) + this.substr(start + length);
};
String.prototype.splitOuter = function (splitter, start, end) {
    if (typeof start == "string")
        start = [start];
    if (typeof end == "string")
        end = [end];
    var str = this;
    var mCount = arrays(start.length, 0);
    var sLens = start.map(e => e.length);
    var splitterLength = splitter.length;
    var list = [];
    var splitPoint = 0;
    let canSplit = true;
    for (let i = 0; i < str.length; i++) {
        canSplit = true;
        for (let j = 0; j < start.length; j++) {
            const _sEl = start[j];
            const _eEl = end[j];
            if (str.substr(i, sLens[j]) == _sEl) {
                mCount[j]++;
            }
            if (str.substr(i, sLens[j]) == _eEl) {
                mCount[j]--;
            }
            if (mCount[j] != 0)
                canSplit = false;
        }
        if (canSplit && str.substr(i, splitterLength) == splitter) {
            list.push(str.substr(splitPoint, i - splitPoint));
            splitPoint = i + 1;
        }
    }
    list.push(str.substr(splitPoint));
    return list;
};
Number.prototype.toDigit = function (x) {
    var str = this.toString();
    var len = str.length;
    for (; x > len; len++) {
        str = "0" + str;
    }
    return str;
};
// MATH BASICS
/**
 * return a array
 * @param start
 * @param end
 */
const range = function (start, end) {
    var ret = [];
    for (let i = start; start < end ? i <= end : i >= start; start < end ? i++ : i--)
        ret.push(i);
    return ret;
};
const arrays = function (count, value = 0) {
    var ret = [];
    for (let i = 0; i < count; i++) {
        ret.push(value);
    }
    return ret;
};
/**
 * positive range
 * return a array
 * @param start
 * @param end
 */
const prange = function (start, end) {
    var ret = [];
    for (let i = start; i <= end; i++)
        ret.push(i);
    return ret;
};
/**
 * negative return a array
 * @param start
 * @param end
 */
const nrange = function (start, end) {
    var ret = [];
    for (let i = start; i >= start; i--)
        ret.push(i);
    return ret;
};
const val = function (data, def) {
    if (data != null)
        return data;
    return def;
};
/** ================= cval ================= */
function cval(obj, arr, defVal) {
    if (defVal === undefined)
        defVal = cval.defValue;
    if (obj == null) {
        return defVal;
    }
    if (arr.length == 0) {
        return obj;
    }
    else {
        var index = arr.popAt(0);
        if (typeof (obj) == "object" && index in obj) {
            return cval(obj[index], arr, defVal);
        }
        else {
            return defVal;
        }
    }
}
cval.defValue = null;
if (typeof process != "undefined")
    globalThis.cval = cval;
/**
 * Convert json to href\n
 *	Example
 * 	url: user
 *  parameters: {name:"Hasan"}
 * 	user?name=Hasan
 * @param url
 * @param parameters
 */
function $H(url, parameters) {
    var qs = "";
    for (var key in parameters) {
        var value = parameters[key];
        qs += encodeURIComponent(key) + "=" + encodeURIComponent(value) + "&";
    }
    if (qs.length > 0) {
        qs = qs.substring(0, qs.length - 1); //chop off last "&"
        url = url + "?" + qs;
    }
    return url;
}
/**
    Tree Hierarchy

    _id			:number
    _children	:list
    _text		:string
    _data		:storage data

 */
/**
 *
 * @param {*} tree Tree mechanzim.
 * @param {*} fn Function <item, text[], id[]> return boolean
 * @param {*} ret Function <item, text[], id[]>
 */
function TreeFilter(tree, fn, ret) {
    if (ret == null)
        ret = e => e;
    let retList = [];
    TreeFilterReq(tree, [], []);
    function TreeFilterReq(tree, textList, idList) {
        for (let i = 0; i < tree.length; i++) {
            const element = tree[i];
            if (fn(element, [].concat(textList, element._text), [].concat(idList, element._id))) {
                retList.push(ret(element, [].concat(textList, element._text), [].concat(idList, element._id)));
            }
            if (typeof (element) == "object" && element != null && "_children" in element) {
                TreeFilterReq(element._children, [].concat(textList, element._text), [].concat(idList, element._id));
            }
        }
    }
    return retList;
}
if (typeof process != "undefined")
    globalThis.TreeFilter = TreeFilter;
if (typeof window !== 'undefined') {
    const Append = function (parent, child) {
        if (child instanceof Array) {
            let fragment = document.createDocumentFragment();
            for (let i = 0; i < child.length; i++) {
                const element = child[i];
                console.log(element);
                fragment.appendChild(element);
            }
            console.log(fragment);
            parent.append(fragment);
        }
        if (child instanceof Object) {
            var keys = Object.keys(child);
            for (let i = 0; i < keys.length; i++) {
                const element = child[keys[i]];
                if (element instanceof Element) {
                    parent.appendChild(element);
                }
            }
        }
        if (child instanceof Element) {
            parent.appendChild(child);
        }
        if (child instanceof Text) {
            parent.appendChild(child);
        }
    };
    DocumentFragment.prototype.empty = function () {
        for (let i = 0; i < this.childNodes.length; i++) {
            const element = this.childNodes[i];
            this.removeChild(element);
        }
    };
    Element.prototype.remove = function () {
        this.parentElement.removeChild(this);
    };
    Element.prototype.empty = function () {
        while (this.childNodes.length > 0) {
            this.firstChild.remove();
        }
    };
}
var Asenac;
(function (Asenac) {
    // ----- DEFAULTS ---------
    Asenac.DEFAULT_TAG = "div";
    Asenac.DEFAULT_EVAL_LANG = "-browser";
    Asenac.DEFAULT_INDENT_LENGTH = 2;
})(Asenac || (Asenac = {}));
var Asenac;
(function (Asenac) {
    function GetJsonAsenac(code) {
        return JsonAsenac.GetJsonAsenac(code);
    }
    Asenac.GetJsonAsenac = GetJsonAsenac;
    let JsonAsenac;
    (function (JsonAsenac) {
        function GetJsonAsenac(code) {
            return ToAsenaJson(PreAsenac.GetPreAsenac(code));
        }
        JsonAsenac.GetJsonAsenac = GetJsonAsenac;
        /**
         * Main ToAsenaJson Function
        */
        const ToAsenaJson = function (list) {
            let children = [];
            for (let i = 0; i < list.length; i++) {
                const element = list[i];
                const code = element.code.trimLeft(); //.trim();
                let child = {
                    code: code,
                    line: element.line,
                    children: [],
                    type: null
                };
                child.type = ToAsenaJson._Single(code);
                /*
                if(child.type.type=="Html" && child.type.html.trim()==""){
                    //@ts-ignore
                    child.type.html = child.children[0]
                    return;
                }
                */
                if (element.children.length > 0)
                    child.children = ToAsenaJson(element.children);
                children.push(child);
            }
            // Update If, Else If, Else Condution
            let i = -1;
            while (i + 1 < children.length) {
                i++;
                const element = children[i];
                if (element.type.type == "If") {
                    let ifCondution = {
                        code: element.code,
                        line: element.line,
                        children: element.children,
                        type: {
                            type: "If",
                            ifParent: element.type.ifParent,
                            condution: element.type.condution
                        }
                    };
                    element.type =
                        {
                            type: "IfAll",
                            condutionChildren: [],
                            "ifParent": element.type.ifParent
                        };
                    element.children = [];
                    element.type.condutionChildren.push(ifCondution);
                    let ifAll = element.type;
                    for (let j = i + 1; j < children.length; j++) {
                        const element_else = children[j];
                        if (element_else.type.type == "Else" || element_else.type.type == "ElseIf") {
                            ifAll.condutionChildren.push(children.popAt(j));
                            j--;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
            return children;
        };
        ToAsenaJson._Single = function (code) {
            let preCode = code.substr(0, 2);
            let afterCode = code.substr(2);
            let type;
            if (preCode == "::") {
                type = ToAsenaJson.For(code);
            }
            else if (preCode == ":?") {
                type = ToAsenaJson.If(code);
            }
            else if (preCode == ":!" && afterCode != "") {
                type = ToAsenaJson.ElseIf(code);
            }
            else if (preCode == ":!" && afterCode == "") {
                type = ToAsenaJson.Else(code);
            }
            else if (preCode == ":#") {
                type = ToAsenaJson.Replace(code);
            }
            else if (preCode == ":+") {
                type = ToAsenaJson.Append(code);
            }
            else if (preCode == ":>") {
                type = ToAsenaJson.SetSelector(code);
            }
            else if (preCode == "->") {
                type = ToAsenaJson.Goto(code);
            }
            else if (code.substr(0, 1) == ":") {
                type = ToAsenaJson.ReturnObject(code);
            }
            else if (code.substr(0, 1) == "-") {
                type = ToAsenaJson.Eval(code);
            }
            else if (code.substr(0, 1) == ">") {
                type = ToAsenaJson.Text(code);
            }
            else if (code.substr(0, 5) == "html.") {
                type = ToAsenaJson.Html(code);
            }
            else {
                type = ToAsenaJson.Crel(code);
            }
            return type;
        };
        /**
         * Create Element Object
         */
        ToAsenaJson.Crel = function (script) {
            var realScript = script;
            //try{
            var retCrel = { crel: {}, type: "Crel" };
            var ret = retCrel.crel;
            var mat = null;
            // Calc Inner HTML
            if ((mat = script.indexOf(">"))) {
                var _tagIndex = mat;
                var _removedBracket = script.toString();
                while ((mat = _removedBracket.matchRequirsive("[", "]")) != null) {
                    if (mat[2] > _tagIndex)
                        break;
                    _removedBracket = _removedBracket.replace(mat[0], "");
                    _tagIndex = _removedBracket.indexOf(">");
                }
                mat = _removedBracket.match(/\>(.*)$/);
                ret.innerHtml = cval(mat, [1], "");
                if (mat != null)
                    script = script.replace(mat[0], "");
            }
            let attrList = [];
            mat = null;
            while ((mat = script.matchRequirsive("[", "]")) != null) {
                attrList.push(mat[1]);
                script = script.replace(mat[0], "");
            }
            ret.tagName = cval(script.match(/^([^\#\.\[\>]+)/), [0], Asenac.DEFAULT_TAG);
            ret.id = cval(script.match(/\#([^\.\#\[\>]*)/), [1], null);
            if (ret.id != null)
                ret.id = ret.id.replace("#", "");
            let classList = script.match(/\.([^\.\#\[\>]*)/gi);
            ret.className = null;
            if (classList != null) {
                for (var i = 0; i < classList.length; i++) {
                    classList[i] = classList[i].replace(".", "");
                }
                ret.className = classList.join(" ");
            }
            ret.attrs = [];
            if (attrList != null) {
                for (var i = 0; i < attrList.length; i++) {
                    var attr = attrList[i];
                    let data = "", value = "";
                    var equalIndex = attr.indexOf("=");
                    if (equalIndex == -1) {
                        data = attr;
                    }
                    else {
                        data = attr.substr(0, equalIndex).trim();
                        value = attr.substr(equalIndex + 1);
                    }
                    ret.attrs.push({ data: data, value: value });
                }
            }
            /*
            }catch(e){
                console.warn("Crel: error in\n",realScript);
            }
            */
            if (ret.className == null)
                ret.className = "";
            if (ret.id == null)
                ret.id = "";
            if (ret.tagName == null)
                ret.tagName = "";
            if (ret.innerHtml == null)
                ret.innerHtml = "";
            ret.tagName = ret.tagName.trim();
            ret.id = ret.id.trim();
            ret.className = ret.className.trim();
            return { crel: ret, type: "Crel" };
        };
        /* #####################    FOR     ##########################
            :: iterator : key
        */
        ToAsenaJson.For = function (code) {
            let decode = code.substr(2); // -> $forData
            let forEval = decode; // -> forEval
            let forKey = ""; // -> $$anahtar
            let forParent = "";
            var mat = null;
            // :
            mat = decode.split(/(?<=[^\\]):/);
            forEval = mat[0];
            forKey = cval(mat, [1], "").trim();
            forParent = cval(mat, [2], "");
            let crelElement = forParent.trim() != "" ? ToAsenaJson.Crel(forParent) : null;
            return {
                forEval: forEval,
                forKey: forKey,
                forParent: crelElement,
                type: "For"
            };
        };
        /* #####################    IF     ##########################
            :? If Eval
        */
        ToAsenaJson.If = function (code) {
            let decode = code.substr(2); // -
            decode = decode.trim();
            let ifStatement = "";
            let createElement = Asenac.DEFAULT_TAG;
            let splitted = decode.split(/(?<=[^\\]):/);
            ifStatement = splitted[0];
            var crelObj = null;
            createElement = cval(splitted, [1], "");
            if (createElement.trim() != "")
                crelObj = ToAsenaJson.Crel(createElement);
            return {
                condution: ifStatement,
                ifParent: crelObj,
                type: "If"
            };
        };
        /* #####################    ELSE IF     ##########################
            :! Else If Eval
        */
        ToAsenaJson.ElseIf = function (code) {
            var decode = code.substr(2); // -
            decode = decode.trim();
            return {
                condution: decode,
                type: "ElseIf"
            };
        };
        /* #####################    ELSE     ##########################
            :!
        */
        ToAsenaJson.Else = function (code) {
            return {
                else: true,
                type: "Else"
            };
        };
        /* #####################    EVAL     ##########################
            - eval
            -php eval
            -node eval
            -browser eval
        */
        ToAsenaJson.Eval = function (code) {
            if (code.startsWith("-php")) {
                return {
                    lang: "-php",
                    eval: code.replace("-php", "").trim(),
                    type: "Eval"
                };
            }
            if (code.startsWith("-node")) {
                return {
                    lang: "-node",
                    eval: code.replace("-node", "").trim(),
                    type: "Eval"
                };
            }
            if (code.startsWith("-browser")) {
                return {
                    lang: "-browser",
                    eval: code.replace("-browser", "").trim(),
                    type: "Eval"
                };
            }
            return {
                lang: Asenac.DEFAULT_EVAL_LANG,
                eval: code.replace("-", "").trim(),
                type: "Eval"
            };
        };
        /* #####################    REPLACE     ##########################
            :# id_name
        */
        ToAsenaJson.Replace = function (code) {
            var decode = code.substr(2); // -
            return {
                replace: decode,
                type: "Replace"
            };
        };
        /* #####################    Goto     ##########################
            -> ViewName > ViewParameters
        */
        ToAsenaJson.Goto = function (code) {
            var decode = code.substr(2); // -
            //var match = decode.match(/([^\>]*)\>(.*)/i)
            var splitted = decode.split(">");
            var gotoParam = splitted.popAt(0).trim();
            // contains bug
            var params = [splitted.join(">")];
            // var params = splitted;
            return {
                goto: gotoParam,
                params: params,
                type: "Goto"
            };
        };
        ToAsenaJson.Text = function (code) {
            let decode = code.trimLeft().substr(1);
            return {
                text: decode,
                type: "Text"
            };
        };
        ToAsenaJson.ReturnObject = function (code) {
            var list = code.split(":");
            list.popAt(0);
            var name = list.popAt(0).trim();
            var objStr = list.join(":").trimLeft();
            var obj = ToAsenaJson._Single(objStr);
            return {
                type: "ReturnObject",
                name: name,
                obj: obj
            };
        };
        ToAsenaJson.Html = function (code) {
            code = code.trim().substr(5);
            return {
                html: code.matchRequirsive("{", "}")[1],
                type: "Html"
            };
        };
        ToAsenaJson.Append = function (code) {
            var decode = code.substr(2).trim(); // -
            return {
                selector: decode,
                type: "Append"
            };
        };
        ToAsenaJson.SetSelector = function (code) {
            var decode = code.substr(2).trim(); // -
            return {
                selector: decode,
                type: "SetSelector"
            };
        };
    })(JsonAsenac = Asenac.JsonAsenac || (Asenac.JsonAsenac = {}));
    let PreAsenac;
    (function (PreAsenac) {
        /**
         * Return number of indent
         * @param line Code
         */
        function GetIndentCount(line) {
            var defIndentLen = Asenac.DEFAULT_INDENT_LENGTH;
            var i = 0, j = 0;
            for (i = 0; i < line.length; i++) {
                if (line[i] == '\t')
                    j += defIndentLen;
                else if (line[i] == " ")
                    j += 1;
                else
                    break;
            }
            return j / defIndentLen;
        }
        function ConvertScriptObject(code) {
            code = code.replaceAll(/\n\s*\.\./, "");
            var codes = code.splitOuter("\n", "{", "}");
            var scriptList = [];
            for (let i = 0; i < codes.length; i++) {
                const element = codes[i];
                let indentCount = GetIndentCount(element);
                let c = element.replace(/^[\ ]*/, "");
                if (c.trim() == "")
                    continue;
                if (c.trim().substr(0, 2) == "//")
                    continue;
                scriptList.push({
                    indent: indentCount,
                    code: c,
                    line: i,
                    children: []
                });
            }
            return scriptList;
        }
        PreAsenac.ConvertScriptObject = ConvertScriptObject;
        function ConvertScriptTree(list, start = 0, index = 0) {
            //console.log( "--",start,index )
            let children = [];
            let continueAt = Infinity;
            for (let i = start; i < list.length; i++) {
                const element = list[i];
                if (continueAt < element.indent) {
                    continue;
                }
                if (element.code.trim() == "html.") {
                    continueAt = index;
                    children.push(element);
                    continue;
                }
                if (element.indent > index) {
                    children[children.length - 1].children = ConvertScriptTree(list, i, element.indent);
                    continueAt = index;
                }
                if (element.indent < index) {
                    break;
                }
                if (element.indent == index) {
                    children.push(element);
                    continueAt = Infinity;
                }
            }
            return children;
        }
        function GetPreAsenac(code) {
            return ConvertScriptTree(ConvertScriptObject(code));
        }
        PreAsenac.GetPreAsenac = GetPreAsenac;
    })(PreAsenac = Asenac.PreAsenac || (Asenac.PreAsenac = {}));
})(Asenac || (Asenac = {}));
//@ts-ignore
if (typeof process != "undefined")
    esprima = require('esprima');
var Asenac;
(function (Asenac) {
    Asenac.PagesText = {};
    Asenac.PagesJson = {};
    Asenac.PagesFunction = {};
    /**
     * Load Asenac View Engine
     */
    function Load(script, name, type = "asenac/function") {
        // Load All 
        if (script == null) {
            let scripts = document.getElementsByTagName("script");
            for (let i = 0; i < scripts.length; i++) {
                const script = scripts[i];
                if (["asenac/realdata", "asenac/function"].indexOf(script.getAttribute("type")) < 0)
                    continue;
                let name = script.getAttribute("name").trim();
                let code = script.textContent;
                Asenac.PagesText[name] = code;
                Asenac.PagesJson[name] = Asenac.GetJsonAsenac(code);
                if (script.type == "asenac/realdata") {
                }
                if (script.type == "asenac/function") {
                    BrowserView.complie(code);
                }
            }
        }
        else {
            Asenac.PagesText[name] = script;
            Asenac.PagesJson[name] = Asenac.GetJsonAsenac(script);
            if (type == "asenac/realdata") {
            }
            if (type == "asenac/function") {
                Asenac.PagesFunction[name] = BrowserView.complie(script);
            }
        }
    }
    Asenac.Load = Load;
    function Complie(pageName, ...parameters) {
        if (pageName in Asenac.PagesFunction) {
            return ComplieBrowserFunction.bind(this)(pageName, ...parameters);
        }
        else {
            return ComplieBrowserRealData.bind(this)(pageName, ...parameters);
        }
    }
    Asenac.Complie = Complie;
    function ComplieBrowserFunction(pageName, ...parameters) {
        return Asenac.PagesFunction[pageName].bind(this)(...parameters);
    }
    Asenac.ComplieBrowserFunction = ComplieBrowserFunction;
    function ComplieBrowserRealData(pageName, ...parameters) {
        return Asenac.BrowserViewRealData.complie.bind(this)(pageName, ...parameters);
    }
    Asenac.ComplieBrowserRealData = ComplieBrowserRealData;
    let BrowserView;
    (function (BrowserView) {
        function complie(asena) {
            let fn = null;
            if (typeof (asena) == "string") {
                asena = Asenac.GetJsonAsenac(asena);
            }
            var fnStr = CreateFunctionMain(asena);
            if (typeof fnStr == "string") {
                fn = eval(fnStr);
            }
            else {
                fn = function (Self, Global) {
                    return document.createDocumentFragment();
                };
            }
            return fn;
        }
        BrowserView.complie = complie;
        /**
         *
         * @param asena
         * @param page For Error Throw asenac page name
         */
        function complieFunctionString(asena, page) {
            if (typeof (asena) == "string") {
                asena = Asenac.GetJsonAsenac(asena);
            }
            var fnStr = "(" + CreateFunctionMain(asena) + ")";
            try {
                //@ts-ignore
                esprima.parseScript(fnStr, { tolerant: true });
                return "(" + CreateFunctionMainTry(asena, page) + ")";
            }
            catch (e) {
                var lineNumber = e.lineNumber;
                var index = e.index;
                var commentStart = fnStr.lastIndexOf("/*LINE:", index);
                var commentCode = fnStr.substr(commentStart + 2, fnStr.indexOf("*/", commentStart) - commentStart - 2);
                var errorMessage = e.message + "\n" + "\nPAGE:" + page + " " + commentCode;
                var line = commentCode.match(/LINE\:(\d+)/m)[1];
                var code = commentCode.match(/CODE\:(.*)$/m)[1];
                return { error: {
                        page: page,
                        line: line,
                        code: code,
                        message: `ERROR:${e.message}\nPAGE:${page}\nLINE:${line}\nCODE:${code}`.replaceAll("${", "$\\{")
                    } };
            }
        }
        BrowserView.complieFunctionString = complieFunctionString;
        /**
         * CreateFunctionMain
         * @param {string} name Page global page name
         */
        function CreateFunctionMainTry(asena, name) {
            let code = "function(Self,Global){\n";
            code += "try{";
            code += "if(Global==void 0) Global=Self;";
            code += "let ___that=this;\n";
            code += "let Keys={};\n";
            code += "let ___lastForKey=null;\n";
            code += "let Parent = document.createDocumentFragment();\n";
            code += "Asenac.Docs.push(Parent);\n";
            code += CreateFunction(asena);
            code += "return Parent;\n";
            code += `}catch(e){ console.warn('Runtime Error. Page: ${name}\\n',e)}`;
            code += "}\n";
            return code;
        }
        /**
         * CreateFunctionMain
         */
        function CreateFunctionMain(asena) {
            let code = "function(Self,Global){\n";
            code += "if(Global==void 0) Global=Self;";
            code += "let ___that=this;\n";
            code += "let Keys={};\n";
            code += "let ___lastForKey=null;\n";
            code += "let Parent = document.createDocumentFragment();\n";
            code += "Asenac.Docs.push(Parent);\n";
            code += CreateFunction(asena);
            code += "return Parent;\n";
            code += "}\n";
            return code;
        }
        BrowserView.CreateFunctionMain = CreateFunctionMain;
        /**
         * CreateFunctionMain using on Replace function
         */
        function CreateFunctionChildren(asena) {
            let code = "function(Self,Global){\n";
            code += "if(Global==void 0) Global=Self;";
            code += "let Parent = document.createDocumentFragment();\n";
            code += "Asenac.Docs.push(Parent);\n";
            code += CreateFunction(asena);
            code += "return Parent;\n";
            code += "};";
            return code;
        }
        /**
         * CreateFunction
         */
        function CreateFunction(asena) {
            let code = "";
            for (let i = 0; i < asena.length; i++) {
                const single = asena[i];
                code += "/*LINE:" + single.line + ", CODE:" + single.code + " */\n";
                /// TEXT
                if (single.type.type == "Text") {
                    code += "{\n" + Text(single.type);
                    code += "Parent.append(Element);\n}\n";
                }
                /// CREL
                if (single.type.type == "Crel") {
                    code += "{\n" + Crel(single.type);
                    if (single.children.length) {
                        code += "{\n";
                        code += "let Parent=Element;\n";
                        code += CreateFunction(single.children);
                        code += "}\n";
                    }
                    code += "Parent.append(Element);\n};\n";
                }
                /// IF
                if (single.type.type == "IfAll") {
                    code += If(single.type);
                }
                /// FOR
                if (single.type.type == "For") {
                    code += For(single);
                }
                /// REPLACE
                if (single.type.type == "Replace") {
                    code += Replace(single);
                }
                /// APPEND
                if (single.type.type == "Append") {
                    code += Append(single);
                }
                /// APPEND
                if (single.type.type == "SetSelector") {
                    code += SetSelector(single);
                }
                /// GOTO
                if (single.type.type == "Goto") {
                    code += Goto(single);
                }
                /// HTML
                if (single.type.type == "Html") {
                    code += Html(single.type);
                }
                /// EVAL
                if (single.type.type == "Eval") {
                    code += Eval(single);
                }
                /// RETURN OBJECT + CREL
                if (single.type.type == "ReturnObject" && single.type.obj.type == "Crel") {
                    code += "{\n" + Crel(single.type.obj);
                    if (single.children.length) {
                        code += "{\n";
                        code += "let Parent=Element;\n";
                        code += CreateFunction(single.children);
                        code += "}\n";
                    }
                    code += "___that[" + EvalOuter(single.type.name) + "]=Element;\n";
                    code += "Parent.append(Element);\n};\n";
                }
            }
            return code;
        }
        function Text(asena) {
            let code = "";
            code += "let Element = document.createTextNode(" + EvalOuter(asena.text) + ");\n";
            return code;
        }
        function Crel(asena) {
            let code = "";
            code += "let Element = document.createElement(" + str(asena.crel.tagName) + ");\n";
            if (asena.crel.className)
                code += "Element.className=" + str(asena.crel.className) + ";\n";
            if (asena.crel.id) {
                code += "Element.id=" + str(asena.crel.id) + ";\n";
            }
            for (var i = 0; i < asena.crel.attrs.length; i++) {
                let value = EvalOuter(asena.crel.attrs[i].value);
                let data = EvalOuter(asena.crel.attrs[i].data);
                if (data.substr(0, 2) == "`@") {
                    data = "`" + data.substr(2);
                    code += "let ___data=" + value + ";if(___data.trim()!='') Element.setAttribute(" + data + "," + value + ");\n";
                }
                else {
                    code += "Element.setAttribute(" + data + "," + value + ");\n";
                }
            }
            if (asena.crel.innerHtml) {
                code += "___innerHTML = " + EvalOuter(asena.crel.innerHtml) + ";\n";
                code += "if(___innerHTML instanceof Node) Element.append(___innerHTML); else Element.innerHTML=___innerHTML;";
                //code += "Element.innerHTML =" + EvalOuter(asena.crel.innerHtml) + ";\n"
            }
            return code;
        }
        /**
         * If
         */
        function If(asena) {
            let code = "";
            /*
            code += "if("+this.EvalInner(asena.condution)+"){\n";
            code += this.Crel(asena.ifCrel);
            code +="}";
            */
            for (let i = 0; i < asena.condutionChildren.length; i++) {
                const c = asena.condutionChildren[i];
                if (c.type.type == "If") {
                    code += "if(" + EvalInner(c.type.condution) + "){\n";
                }
                if (c.type.type == "ElseIf") {
                    code += "else if(" + EvalInner(c.type.condution) + "){\n";
                }
                if (c.type.type == "Else") {
                    code += "else{\n";
                }
                code += CreateFunction(c.children);
                code += "}";
            }
            return code;
        }
        /**
         * For
         */
        function For(asena) {
            let code = "{\n";
            if (asena.type.type == "For") {
                if (asena.type.forParent) {
                    code += Crel(asena.type.forParent);
                    code += "Parent.append(Element);\n";
                    code += "{\n let Parent=Element;\n";
                }
                code += "let ___iterators=" + EvalInner(asena.type.forEval) + ";";
                code += "let ___forKeyName=" + EvalOuter(asena.type.forKey) + ";";
                code += "for (let ___key in ___iterators) {\n";
                code += "if (___iterators.hasOwnProperty(___key)) {\n";
                code += "Keys[___forKeyName]=___key;\n";
                code += "___lastForKey=___key;\n";
                code += "let Self=___iterators[___key];\n";
                code += CreateFunction(asena.children);
                if (asena.type.forParent) {
                    code += "}\n";
                }
                code += "}\n";
                code += "}\n";
                code += "};\n";
            }
            return code;
        }
        /**
         * Replace
         */
        function Replace(asena) {
            let code = "{\n";
            if (asena.type.type == "Replace") {
                code += "let ___replaceEl=document.getElementById(" + str(asena.type.replace) + ")\n";
                code += "let ___replaceFunction=" + CreateFunctionChildren(asena.children);
                code += "if(___replaceEl){\n";
                code += "___replaceEl.empty();\n";
                code += "___replaceEl.append( ___replaceFunction(Self,Global) );";
                code += "}\n";
            }
            return code + "};\n";
        }
        /**
         * Append
         */
        function Append(asena) {
            let code = "{\n";
            if (asena.type.type == "Append") {
                code += "let ___appendEl=Asenac.Query(" + str(asena.type.selector) + ");\n";
                //code+="let ___appendEl=document.getElementById("+ str(asena.type.append) +")\n";
                code += "let ___replaceFunction=" + CreateFunctionChildren(asena.children);
                code += "for(___el of ___appendEl){\n";
                code += "___el.append( ___replaceFunction(Self,Global) );";
                code += "}\n";
            }
            return code + "};\n";
        }
        /**
         * Append
         */
        function SetSelector(asena) {
            let code = "{\n";
            if (asena.type.type == "SetSelector") {
                code += "let ___appendEl=Asenac.Query(" + str(asena.type.selector) + ");\n";
                //code+="let ___appendEl=document.getElementById("+ str(asena.type.append) +")\n";
                code += "let ___replaceFunction=" + CreateFunctionChildren(asena.children);
                code += "for(___el of ___appendEl){\n";
                code += "___el.empty();\n";
                code += "___el.append( ___replaceFunction(Self,Global) );";
                code += "}\n";
            }
            return code + "};\n";
        }
        function Goto(asena) {
            let code = "";
            if (asena.type.type == "Goto") {
                code += "Parent.append( Asenac(" + str(asena.type.goto) + "," + EvalInner(asena.type.params[0]) + ") );";
            }
            return code;
        }
        function Html(asena) {
            let code = "{\n";
            code += "let ___temp = document.createElement('div');\n ";
            code += "___temp.innerHTML = " + EvalOuter(asena.html) + ";\n";
            code += "while (___temp.firstChild) Parent.append(___temp.firstChild);\n}\n";
            return code;
        }
        /**
         * Eval
         */
        function Eval(asena) {
            if (asena.type.type == "Eval") {
                return EvalInner(asena.type.eval) + ";\n";
            }
            return "";
        }
        /**
         * Eval Standarts
         * $val$val$val
         * $$$global_var
         * $$keyval
         *
         * $   -> self
         * $$  -> array self
         * $$$ -> global self
         *
         * @$   -> string or htmlElement
         * @$$$ -> string or htmlElement
         *
         *
         * Global   -> global data
         * Self     -> self data. change in { self= xyz }
         * Keys      -> for each keys
         * ___lastForKey   -> Last For Key
         *
         * {{  }}  -> complie previusly
         *
         * -----------------------------------------------------------
         */
        /**
         * EvalOuter
         */
        function EvalOuter(script) {
            // {{ previusly }}
            var mat = null;
            // @$$$var
            if ((mat = script.match(/\@\$\$\$([\w\_]+)/))) {
                return "Global[" + str(mat[0]) + "]";
            }
            // @$$var
            if ((mat = script.match(/\@\$([\w\_]+)/))) {
                return "Self[" + str(mat[0]) + "]";
            }
            // @{{ var }}
            if ((mat = script.match(/\@\{\{/))) {
                mat = script.matchRequirsive("{{", "}}");
                return EvalInner(mat[1]);
            }
            while ((mat = script.matchRequirsive("{{{", "}}}"))) {
                script = script.replace(mat[0], "\`+" + EvalInner(mat[1]) + "+\`");
            }
            while ((mat = script.matchRequirsive("{{", "}}"))) {
                script = script.replace(mat[0], "\`+" + EvalInner(mat[1]) + "+\`");
            }
            for (let i = 0; i < EvalChangeList.length; i++) {
                let ch = EvalChangeList[i];
                script = EvalChange(ch.reg, script, "\`+" + ch.prev, ch.next + "+\`", ch.split, ch.join);
            }
            return "\`" + script + "\`";
        }
        /**
         * Eval Inner Return variables
         */
        function EvalInner(script) {
            // {{ previusly }}
            var mat = null;
            while ((mat = script.matchRequirsive("{{{", "}}}"))) {
                script = script.replace(mat[0], EvalInner(mat[1]));
            }
            for (let i = 0; i < EvalChangeList.length; i++) {
                let ch = EvalChangeList[i];
                script = EvalChange(ch.reg, script, ch.prev, ch.next, ch.split, ch.join);
            }
            while ((mat = script.matchRequirsive("{{", "}}"))) {
                script = script.replace(mat[0], EvalInner(mat[1]));
            }
            return script;
        }
        const EvalChangeList = [{
                reg: /\$\$\$([\w\_\$\.]+)/,
                prev: "Global",
                split: /[\$\.]/,
                join: "\"][\"",
                next: ""
            }, {
                reg: /\$\$\$([\w\_]+)/,
                prev: "Global",
                next: ""
            }, {
                reg: /\$\$([\w\_]+)/,
                prev: "Keys",
                next: ""
            }, {
                reg: /\$\$/,
                prev: "___lastForKey",
                next: ""
            }, {
                reg: /\$([\w\_\$\.]+)/,
                prev: "Self",
                split: /[\$\.]/,
                join: "\"][\"",
                next: ""
            }, {
                reg: /\$([\w\_]+)/,
                prev: "Self",
                next: ""
            }, {
                reg: /\$/,
                prev: "Self",
                next: ""
            }];
        function EvalChange(reg, script, prev, next, split = null, join = "") {
            var mat = null;
            while ((mat = script.match(reg)) != null) {
                if (mat.length > 1) {
                    var list = mat[1];
                    if (split != null)
                        list = list.split(split).join(join);
                    script = script.replace(mat[0], prev + "[\"" + list + "\"]" + next);
                    // selfData['name']
                }
                else {
                    script = script.replace(mat[0], prev + next);
                }
            }
            return script;
        }
        /**
         * str
         */
        function str(string) {
            return "\"" + string.toString().replaceAll("\"", "\\\"") + "\"";
        }
    })(BrowserView = Asenac.BrowserView || (Asenac.BrowserView = {}));
})(Asenac || (Asenac = {}));
exports.Asenac=Asenac
